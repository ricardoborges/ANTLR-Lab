//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g 2012-03-07 22:22:43

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class CMinusParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ARG", "FUNC", "ID", "INT", "SLIST", "VAR", "WS", "'!='", "'('", "')'", "'*'", "'+'", "','", "';'", "'='", "'=='", "'char'", "'for'", "'int'", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int T__11=11;
	public const int T__12=12;
	public const int T__13=13;
	public const int T__14=14;
	public const int T__15=15;
	public const int T__16=16;
	public const int T__17=17;
	public const int T__18=18;
	public const int T__19=19;
	public const int T__20=20;
	public const int T__21=21;
	public const int T__22=22;
	public const int T__23=23;
	public const int T__24=24;
	public const int ARG=4;
	public const int FUNC=5;
	public const int ID=6;
	public const int INT=7;
	public const int SLIST=8;
	public const int VAR=9;
	public const int WS=10;

	public CMinusParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public CMinusParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return CMinusParser.tokenNames; } }
	public override string GrammarFileName { get { return "E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:15:8: public program : ( declaration )+ ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declaration1 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(15, 4);
		try
		{
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:16:5: ( ( declaration )+ )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:16:9: ( declaration )+
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(16, 9);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:16:9: ( declaration )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==20||LA1_0==22))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:16:9: declaration
					{
					DebugLocation(16, 9);
					PushFollow(Follow._declaration_in_program67);
					declaration1=declaration();
					PopFollow();

					adaptor.AddChild(root_0, declaration1.Tree);

					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(17, 4);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_declaration();
	partial void LeaveRule_declaration();

	// $ANTLR start "declaration"
	// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:19:1: declaration : ( variable | function );
	[GrammarRule("declaration")]
	private AstParserRuleReturnScope<object, IToken> declaration()
	{
		EnterRule_declaration();
		EnterRule("declaration", 2);
		TraceIn("declaration", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> variable2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> function3 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "declaration");
		DebugLocation(19, 4);
		try
		{
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:20:5: ( variable | function )
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==20||LA2_0==22))
			{
				int LA2_1 = input.LA(2);

				if ((LA2_1==ID))
				{
					int LA2_2 = input.LA(3);

					if ((LA2_2==17))
					{
						alt2 = 1;
					}
					else if ((LA2_2==12))
					{
						alt2 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 2, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:20:9: variable
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(20, 9);
				PushFollow(Follow._variable_in_declaration87);
				variable2=variable();
				PopFollow();

				adaptor.AddChild(root_0, variable2.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:21:9: function
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(21, 9);
				PushFollow(Follow._function_in_declaration97);
				function3=function();
				PopFollow();

				adaptor.AddChild(root_0, function3.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration", 2);
			LeaveRule("declaration", 2);
			LeaveRule_declaration();
		}
		DebugLocation(22, 4);
		} finally { DebugExitRule(GrammarFileName, "declaration"); }
		return retval;

	}
	// $ANTLR end "declaration"

	partial void EnterRule_variable();
	partial void LeaveRule_variable();

	// $ANTLR start "variable"
	// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:24:1: variable : type ID ';' -> ^( VAR type ID ) ;
	[GrammarRule("variable")]
	private AstParserRuleReturnScope<object, IToken> variable()
	{
		EnterRule_variable();
		EnterRule("variable", 3);
		TraceIn("variable", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID5 = default(IToken);
		IToken char_literal6 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type4 = default(AstParserRuleReturnScope<object, IToken>);

		object ID5_tree = default(object);
		object char_literal6_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_17=new RewriteRuleITokenStream(adaptor,"token 17");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "variable");
		DebugLocation(24, 4);
		try
		{
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:25:5: ( type ID ';' -> ^( VAR type ID ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:25:9: type ID ';'
			{
			DebugLocation(25, 9);
			PushFollow(Follow._type_in_variable116);
			type4=type();
			PopFollow();

			stream_type.Add(type4.Tree);
			DebugLocation(25, 14);
			ID5=(IToken)Match(input,ID,Follow._ID_in_variable118);  
			stream_ID.Add(ID5);

			DebugLocation(25, 17);
			char_literal6=(IToken)Match(input,17,Follow._17_in_variable120);  
			stream_17.Add(char_literal6);



			{
			// AST REWRITE
			// elements: type, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 25:21: -> ^( VAR type ID )
			{
				DebugLocation(25, 24);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:25:24: ^( VAR type ID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(25, 26);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR, "VAR"), root_1);

				DebugLocation(25, 30);
				adaptor.AddChild(root_1, stream_type.NextTree());
				DebugLocation(25, 35);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variable", 3);
			LeaveRule("variable", 3);
			LeaveRule_variable();
		}
		DebugLocation(26, 4);
		} finally { DebugExitRule(GrammarFileName, "variable"); }
		return retval;

	}
	// $ANTLR end "variable"

	partial void EnterRule_type();
	partial void LeaveRule_type();

	// $ANTLR start "type"
	// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:28:1: type : ( 'int' | 'char' );
	[GrammarRule("type")]
	private AstParserRuleReturnScope<object, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 4);
		TraceIn("type", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set7 = default(IToken);

		object set7_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(28, 4);
		try
		{
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:28:5: ( 'int' | 'char' )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(28, 5);

			set7=(IToken)input.LT(1);
			if (input.LA(1)==20||input.LA(1)==22)
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set7));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 4);
			LeaveRule("type", 4);
			LeaveRule_type();
		}
		DebugLocation(30, 4);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	partial void EnterRule_function();
	partial void LeaveRule_function();

	// $ANTLR start "function"
	// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:32:1: function : type ID '(' ( formalParameter ( ',' formalParameter )* )? ')' block -> ^( FUNC type ID ( formalParameter )* block ) ;
	[GrammarRule("function")]
	private AstParserRuleReturnScope<object, IToken> function()
	{
		EnterRule_function();
		EnterRule("function", 5);
		TraceIn("function", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID9 = default(IToken);
		IToken char_literal10 = default(IToken);
		IToken char_literal12 = default(IToken);
		IToken char_literal14 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type8 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> formalParameter11 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> formalParameter13 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> block15 = default(AstParserRuleReturnScope<object, IToken>);

		object ID9_tree = default(object);
		object char_literal10_tree = default(object);
		object char_literal12_tree = default(object);
		object char_literal14_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_16=new RewriteRuleITokenStream(adaptor,"token 16");
		RewriteRuleITokenStream stream_13=new RewriteRuleITokenStream(adaptor,"token 13");
		RewriteRuleITokenStream stream_12=new RewriteRuleITokenStream(adaptor,"token 12");
		RewriteRuleSubtreeStream stream_formalParameter=new RewriteRuleSubtreeStream(adaptor,"rule formalParameter");
		RewriteRuleSubtreeStream stream_block=new RewriteRuleSubtreeStream(adaptor,"rule block");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "function");
		DebugLocation(32, 4);
		try
		{
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:33:5: ( type ID '(' ( formalParameter ( ',' formalParameter )* )? ')' block -> ^( FUNC type ID ( formalParameter )* block ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:33:9: type ID '(' ( formalParameter ( ',' formalParameter )* )? ')' block
			{
			DebugLocation(33, 9);
			PushFollow(Follow._type_in_function174);
			type8=type();
			PopFollow();

			stream_type.Add(type8.Tree);
			DebugLocation(33, 14);
			ID9=(IToken)Match(input,ID,Follow._ID_in_function176);  
			stream_ID.Add(ID9);

			DebugLocation(34, 9);
			char_literal10=(IToken)Match(input,12,Follow._12_in_function186);  
			stream_12.Add(char_literal10);

			DebugLocation(34, 13);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:34:13: ( formalParameter ( ',' formalParameter )* )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==20||LA4_0==22))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:34:15: formalParameter ( ',' formalParameter )*
				{
				DebugLocation(34, 15);
				PushFollow(Follow._formalParameter_in_function190);
				formalParameter11=formalParameter();
				PopFollow();

				stream_formalParameter.Add(formalParameter11.Tree);
				DebugLocation(34, 31);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:34:31: ( ',' formalParameter )*
				try { DebugEnterSubRule(3);
				while (true)
				{
					int alt3=2;
					try { DebugEnterDecision(3, false);
					int LA3_0 = input.LA(1);

					if ((LA3_0==16))
					{
						alt3 = 1;
					}


					} finally { DebugExitDecision(3); }
					switch ( alt3 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:34:32: ',' formalParameter
						{
						DebugLocation(34, 32);
						char_literal12=(IToken)Match(input,16,Follow._16_in_function193);  
						stream_16.Add(char_literal12);

						DebugLocation(34, 36);
						PushFollow(Follow._formalParameter_in_function195);
						formalParameter13=formalParameter();
						PopFollow();

						stream_formalParameter.Add(formalParameter13.Tree);

						}
						break;

					default:
						goto loop3;
					}
				}

				loop3:
					;

				} finally { DebugExitSubRule(3); }


				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(34, 58);
			char_literal14=(IToken)Match(input,13,Follow._13_in_function203);  
			stream_13.Add(char_literal14);

			DebugLocation(35, 9);
			PushFollow(Follow._block_in_function213);
			block15=block();
			PopFollow();

			stream_block.Add(block15.Tree);


			{
			// AST REWRITE
			// elements: type, block, formalParameter, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 36:9: -> ^( FUNC type ID ( formalParameter )* block )
			{
				DebugLocation(36, 12);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:36:12: ^( FUNC type ID ( formalParameter )* block )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(36, 14);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNC, "FUNC"), root_1);

				DebugLocation(36, 19);
				adaptor.AddChild(root_1, stream_type.NextTree());
				DebugLocation(36, 24);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(36, 27);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:36:27: ( formalParameter )*
				while ( stream_formalParameter.HasNext )
				{
					DebugLocation(36, 27);
					adaptor.AddChild(root_1, stream_formalParameter.NextTree());

				}
				stream_formalParameter.Reset();
				DebugLocation(36, 44);
				adaptor.AddChild(root_1, stream_block.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("function", 5);
			LeaveRule("function", 5);
			LeaveRule_function();
		}
		DebugLocation(37, 4);
		} finally { DebugExitRule(GrammarFileName, "function"); }
		return retval;

	}
	// $ANTLR end "function"

	partial void EnterRule_formalParameter();
	partial void LeaveRule_formalParameter();

	// $ANTLR start "formalParameter"
	// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:39:1: formalParameter : type ID -> ^( ARG type ID ) ;
	[GrammarRule("formalParameter")]
	private AstParserRuleReturnScope<object, IToken> formalParameter()
	{
		EnterRule_formalParameter();
		EnterRule("formalParameter", 6);
		TraceIn("formalParameter", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID17 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type16 = default(AstParserRuleReturnScope<object, IToken>);

		object ID17_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "formalParameter");
		DebugLocation(39, 4);
		try
		{
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:40:5: ( type ID -> ^( ARG type ID ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:40:9: type ID
			{
			DebugLocation(40, 9);
			PushFollow(Follow._type_in_formalParameter255);
			type16=type();
			PopFollow();

			stream_type.Add(type16.Tree);
			DebugLocation(40, 14);
			ID17=(IToken)Match(input,ID,Follow._ID_in_formalParameter257);  
			stream_ID.Add(ID17);



			{
			// AST REWRITE
			// elements: type, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 40:17: -> ^( ARG type ID )
			{
				DebugLocation(40, 20);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:40:20: ^( ARG type ID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(40, 22);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARG, "ARG"), root_1);

				DebugLocation(40, 26);
				adaptor.AddChild(root_1, stream_type.NextTree());
				DebugLocation(40, 31);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("formalParameter", 6);
			LeaveRule("formalParameter", 6);
			LeaveRule_formalParameter();
		}
		DebugLocation(41, 4);
		} finally { DebugExitRule(GrammarFileName, "formalParameter"); }
		return retval;

	}
	// $ANTLR end "formalParameter"

	partial void EnterRule_block();
	partial void LeaveRule_block();

	// $ANTLR start "block"
	// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:44:1: block : lc= '{' ( variable )* ( stat )* '}' -> ^( SLIST[$lc,\"SLIST\"] ( variable )* ( stat )* ) ;
	[GrammarRule("block")]
	private AstParserRuleReturnScope<object, IToken> block()
	{
		EnterRule_block();
		EnterRule("block", 7);
		TraceIn("block", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken lc = default(IToken);
		IToken char_literal20 = default(IToken);
		AstParserRuleReturnScope<object, IToken> variable18 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> stat19 = default(AstParserRuleReturnScope<object, IToken>);

		object lc_tree = default(object);
		object char_literal20_tree = default(object);
		RewriteRuleITokenStream stream_23=new RewriteRuleITokenStream(adaptor,"token 23");
		RewriteRuleITokenStream stream_24=new RewriteRuleITokenStream(adaptor,"token 24");
		RewriteRuleSubtreeStream stream_variable=new RewriteRuleSubtreeStream(adaptor,"rule variable");
		RewriteRuleSubtreeStream stream_stat=new RewriteRuleSubtreeStream(adaptor,"rule stat");
		try { DebugEnterRule(GrammarFileName, "block");
		DebugLocation(44, 4);
		try
		{
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:45:5: (lc= '{' ( variable )* ( stat )* '}' -> ^( SLIST[$lc,\"SLIST\"] ( variable )* ( stat )* ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:45:9: lc= '{' ( variable )* ( stat )* '}'
			{
			DebugLocation(45, 11);
			lc=(IToken)Match(input,23,Follow._23_in_block289);  
			stream_23.Add(lc);

			DebugLocation(45, 16);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:45:16: ( variable )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==20||LA5_0==22))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:45:16: variable
					{
					DebugLocation(45, 16);
					PushFollow(Follow._variable_in_block291);
					variable18=variable();
					PopFollow();

					stream_variable.Add(variable18.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(45, 26);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:45:26: ( stat )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if (((LA6_0>=ID && LA6_0<=INT)||LA6_0==12||LA6_0==17||LA6_0==21||LA6_0==23))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:45:26: stat
					{
					DebugLocation(45, 26);
					PushFollow(Follow._stat_in_block294);
					stat19=stat();
					PopFollow();

					stream_stat.Add(stat19.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(45, 32);
			char_literal20=(IToken)Match(input,24,Follow._24_in_block297);  
			stream_24.Add(char_literal20);



			{
			// AST REWRITE
			// elements: variable, stat
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 46:9: -> ^( SLIST[$lc,\"SLIST\"] ( variable )* ( stat )* )
			{
				DebugLocation(46, 12);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:46:12: ^( SLIST[$lc,\"SLIST\"] ( variable )* ( stat )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(46, 14);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, lc, "SLIST"), root_1);

				DebugLocation(46, 33);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:46:33: ( variable )*
				while ( stream_variable.HasNext )
				{
					DebugLocation(46, 33);
					adaptor.AddChild(root_1, stream_variable.NextTree());

				}
				stream_variable.Reset();
				DebugLocation(46, 43);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:46:43: ( stat )*
				while ( stream_stat.HasNext )
				{
					DebugLocation(46, 43);
					adaptor.AddChild(root_1, stream_stat.NextTree());

				}
				stream_stat.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("block", 7);
			LeaveRule("block", 7);
			LeaveRule_block();
		}
		DebugLocation(47, 4);
		} finally { DebugExitRule(GrammarFileName, "block"); }
		return retval;

	}
	// $ANTLR end "block"

	partial void EnterRule_stat();
	partial void LeaveRule_stat();

	// $ANTLR start "stat"
	// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:49:1: stat : ( forStat | expr ';' !| block | assignStat ';' !| ';' !);
	[GrammarRule("stat")]
	private AstParserRuleReturnScope<object, IToken> stat()
	{
		EnterRule_stat();
		EnterRule("stat", 8);
		TraceIn("stat", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal23 = default(IToken);
		IToken char_literal26 = default(IToken);
		IToken char_literal27 = default(IToken);
		AstParserRuleReturnScope<object, IToken> forStat21 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> block24 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignStat25 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal23_tree = default(object);
		object char_literal26_tree = default(object);
		object char_literal27_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "stat");
		DebugLocation(49, 4);
		try
		{
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:49:5: ( forStat | expr ';' !| block | assignStat ';' !| ';' !)
			int alt7=5;
			try { DebugEnterDecision(7, false);
			switch (input.LA(1))
			{
			case 21:
				{
				alt7 = 1;
				}
				break;
			case ID:
				{
				int LA7_2 = input.LA(2);

				if ((LA7_2==18))
				{
					alt7 = 4;
				}
				else if ((LA7_2==11||(LA7_2>=14 && LA7_2<=15)||LA7_2==17||LA7_2==19))
				{
					alt7 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 7, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INT:
			case 12:
				{
				alt7 = 2;
				}
				break;
			case 23:
				{
				alt7 = 3;
				}
				break;
			case 17:
				{
				alt7 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:49:7: forStat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(49, 7);
				PushFollow(Follow._forStat_in_stat330);
				forStat21=forStat();
				PopFollow();

				adaptor.AddChild(root_0, forStat21.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:50:7: expr ';' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(50, 7);
				PushFollow(Follow._expr_in_stat338);
				expr22=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr22.Tree);
				DebugLocation(50, 15);
				char_literal23=(IToken)Match(input,17,Follow._17_in_stat340); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:51:7: block
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(51, 7);
				PushFollow(Follow._block_in_stat349);
				block24=block();
				PopFollow();

				adaptor.AddChild(root_0, block24.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:52:7: assignStat ';' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(52, 7);
				PushFollow(Follow._assignStat_in_stat357);
				assignStat25=assignStat();
				PopFollow();

				adaptor.AddChild(root_0, assignStat25.Tree);
				DebugLocation(52, 21);
				char_literal26=(IToken)Match(input,17,Follow._17_in_stat359); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:53:7: ';' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(53, 10);
				char_literal27=(IToken)Match(input,17,Follow._17_in_stat368); 

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stat", 8);
			LeaveRule("stat", 8);
			LeaveRule_stat();
		}
		DebugLocation(54, 4);
		} finally { DebugExitRule(GrammarFileName, "stat"); }
		return retval;

	}
	// $ANTLR end "stat"

	partial void EnterRule_forStat();
	partial void LeaveRule_forStat();

	// $ANTLR start "forStat"
	// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:56:1: forStat : 'for' '(' first= assignStat ';' expr ';' inc= assignStat ')' block -> ^( 'for' $first expr $inc block ) ;
	[GrammarRule("forStat")]
	private AstParserRuleReturnScope<object, IToken> forStat()
	{
		EnterRule_forStat();
		EnterRule("forStat", 9);
		TraceIn("forStat", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal28 = default(IToken);
		IToken char_literal29 = default(IToken);
		IToken char_literal30 = default(IToken);
		IToken char_literal32 = default(IToken);
		IToken char_literal33 = default(IToken);
		AstParserRuleReturnScope<object, IToken> first = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> inc = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr31 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> block34 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal28_tree = default(object);
		object char_literal29_tree = default(object);
		object char_literal30_tree = default(object);
		object char_literal32_tree = default(object);
		object char_literal33_tree = default(object);
		RewriteRuleITokenStream stream_21=new RewriteRuleITokenStream(adaptor,"token 21");
		RewriteRuleITokenStream stream_17=new RewriteRuleITokenStream(adaptor,"token 17");
		RewriteRuleITokenStream stream_13=new RewriteRuleITokenStream(adaptor,"token 13");
		RewriteRuleITokenStream stream_12=new RewriteRuleITokenStream(adaptor,"token 12");
		RewriteRuleSubtreeStream stream_assignStat=new RewriteRuleSubtreeStream(adaptor,"rule assignStat");
		RewriteRuleSubtreeStream stream_block=new RewriteRuleSubtreeStream(adaptor,"rule block");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "forStat");
		DebugLocation(56, 4);
		try
		{
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:57:5: ( 'for' '(' first= assignStat ';' expr ';' inc= assignStat ')' block -> ^( 'for' $first expr $inc block ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:57:9: 'for' '(' first= assignStat ';' expr ';' inc= assignStat ')' block
			{
			DebugLocation(57, 9);
			string_literal28=(IToken)Match(input,21,Follow._21_in_forStat388);  
			stream_21.Add(string_literal28);

			DebugLocation(57, 15);
			char_literal29=(IToken)Match(input,12,Follow._12_in_forStat390);  
			stream_12.Add(char_literal29);

			DebugLocation(57, 24);
			PushFollow(Follow._assignStat_in_forStat394);
			first=assignStat();
			PopFollow();

			stream_assignStat.Add(first.Tree);
			DebugLocation(57, 36);
			char_literal30=(IToken)Match(input,17,Follow._17_in_forStat396);  
			stream_17.Add(char_literal30);

			DebugLocation(57, 40);
			PushFollow(Follow._expr_in_forStat398);
			expr31=expr();
			PopFollow();

			stream_expr.Add(expr31.Tree);
			DebugLocation(57, 45);
			char_literal32=(IToken)Match(input,17,Follow._17_in_forStat400);  
			stream_17.Add(char_literal32);

			DebugLocation(57, 52);
			PushFollow(Follow._assignStat_in_forStat404);
			inc=assignStat();
			PopFollow();

			stream_assignStat.Add(inc.Tree);
			DebugLocation(57, 64);
			char_literal33=(IToken)Match(input,13,Follow._13_in_forStat406);  
			stream_13.Add(char_literal33);

			DebugLocation(57, 68);
			PushFollow(Follow._block_in_forStat408);
			block34=block();
			PopFollow();

			stream_block.Add(block34.Tree);


			{
			// AST REWRITE
			// elements: expr, 21, first, inc, block
			// token labels: 
			// rule labels: retval, inc, first
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_inc=new RewriteRuleSubtreeStream(adaptor,"rule inc",inc!=null?inc.Tree:null);
			RewriteRuleSubtreeStream stream_first=new RewriteRuleSubtreeStream(adaptor,"rule first",first!=null?first.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 58:9: -> ^( 'for' $first expr $inc block )
			{
				DebugLocation(58, 12);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:58:12: ^( 'for' $first expr $inc block )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(58, 14);
				root_1 = (object)adaptor.BecomeRoot(stream_21.NextNode(), root_1);

				DebugLocation(58, 21);
				adaptor.AddChild(root_1, stream_first.NextTree());
				DebugLocation(58, 27);
				adaptor.AddChild(root_1, stream_expr.NextTree());
				DebugLocation(58, 33);
				adaptor.AddChild(root_1, stream_inc.NextTree());
				DebugLocation(58, 37);
				adaptor.AddChild(root_1, stream_block.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forStat", 9);
			LeaveRule("forStat", 9);
			LeaveRule_forStat();
		}
		DebugLocation(59, 4);
		} finally { DebugExitRule(GrammarFileName, "forStat"); }
		return retval;

	}
	// $ANTLR end "forStat"

	partial void EnterRule_assignStat();
	partial void LeaveRule_assignStat();

	// $ANTLR start "assignStat"
	// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:61:1: assignStat : ID '=' expr -> ^( '=' ID expr ) ;
	[GrammarRule("assignStat")]
	private AstParserRuleReturnScope<object, IToken> assignStat()
	{
		EnterRule_assignStat();
		EnterRule("assignStat", 10);
		TraceIn("assignStat", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID35 = default(IToken);
		IToken char_literal36 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr37 = default(AstParserRuleReturnScope<object, IToken>);

		object ID35_tree = default(object);
		object char_literal36_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_18=new RewriteRuleITokenStream(adaptor,"token 18");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "assignStat");
		DebugLocation(61, 4);
		try
		{
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:62:5: ( ID '=' expr -> ^( '=' ID expr ) )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:62:9: ID '=' expr
			{
			DebugLocation(62, 9);
			ID35=(IToken)Match(input,ID,Follow._ID_in_assignStat451);  
			stream_ID.Add(ID35);

			DebugLocation(62, 12);
			char_literal36=(IToken)Match(input,18,Follow._18_in_assignStat453);  
			stream_18.Add(char_literal36);

			DebugLocation(62, 16);
			PushFollow(Follow._expr_in_assignStat455);
			expr37=expr();
			PopFollow();

			stream_expr.Add(expr37.Tree);


			{
			// AST REWRITE
			// elements: 18, ID, expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 62:21: -> ^( '=' ID expr )
			{
				DebugLocation(62, 24);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:62:24: ^( '=' ID expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(62, 26);
				root_1 = (object)adaptor.BecomeRoot(stream_18.NextNode(), root_1);

				DebugLocation(62, 30);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(62, 33);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignStat", 10);
			LeaveRule("assignStat", 10);
			LeaveRule_assignStat();
		}
		DebugLocation(63, 4);
		} finally { DebugExitRule(GrammarFileName, "assignStat"); }
		return retval;

	}
	// $ANTLR end "assignStat"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:65:1: expr : condExpr ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<object, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 11);
		TraceIn("expr", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> condExpr38 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(65, 17);
		try
		{
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:65:5: ( condExpr )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:65:9: condExpr
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(65, 9);
			PushFollow(Follow._condExpr_in_expr479);
			condExpr38=condExpr();
			PopFollow();

			adaptor.AddChild(root_0, condExpr38.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 11);
			LeaveRule("expr", 11);
			LeaveRule_expr();
		}
		DebugLocation(65, 17);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_condExpr();
	partial void LeaveRule_condExpr();

	// $ANTLR start "condExpr"
	// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:67:1: condExpr : aexpr ( ( '==' ^| '!=' ^) aexpr )? ;
	[GrammarRule("condExpr")]
	private AstParserRuleReturnScope<object, IToken> condExpr()
	{
		EnterRule_condExpr();
		EnterRule("condExpr", 12);
		TraceIn("condExpr", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal40 = default(IToken);
		IToken string_literal41 = default(IToken);
		AstParserRuleReturnScope<object, IToken> aexpr39 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> aexpr42 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal40_tree = default(object);
		object string_literal41_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "condExpr");
		DebugLocation(67, 4);
		try
		{
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:68:5: ( aexpr ( ( '==' ^| '!=' ^) aexpr )? )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:68:9: aexpr ( ( '==' ^| '!=' ^) aexpr )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(68, 9);
			PushFollow(Follow._aexpr_in_condExpr494);
			aexpr39=aexpr();
			PopFollow();

			adaptor.AddChild(root_0, aexpr39.Tree);
			DebugLocation(68, 15);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:68:15: ( ( '==' ^| '!=' ^) aexpr )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_0 = input.LA(1);

			if ((LA9_0==11||LA9_0==19))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:68:17: ( '==' ^| '!=' ^) aexpr
				{
				DebugLocation(68, 17);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:68:17: ( '==' ^| '!=' ^)
				int alt8=2;
				try { DebugEnterSubRule(8);
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==19))
				{
					alt8 = 1;
				}
				else if ((LA8_0==11))
				{
					alt8 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:68:18: '==' ^
					{
					DebugLocation(68, 22);
					string_literal40=(IToken)Match(input,19,Follow._19_in_condExpr499); 
					string_literal40_tree = (object)adaptor.Create(string_literal40);
					root_0 = (object)adaptor.BecomeRoot(string_literal40_tree, root_0);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:68:24: '!=' ^
					{
					DebugLocation(68, 28);
					string_literal41=(IToken)Match(input,11,Follow._11_in_condExpr502); 
					string_literal41_tree = (object)adaptor.Create(string_literal41);
					root_0 = (object)adaptor.BecomeRoot(string_literal41_tree, root_0);

					}
					break;

				}
				} finally { DebugExitSubRule(8); }

				DebugLocation(68, 31);
				PushFollow(Follow._aexpr_in_condExpr506);
				aexpr42=aexpr();
				PopFollow();

				adaptor.AddChild(root_0, aexpr42.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(9); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("condExpr", 12);
			LeaveRule("condExpr", 12);
			LeaveRule_condExpr();
		}
		DebugLocation(69, 4);
		} finally { DebugExitRule(GrammarFileName, "condExpr"); }
		return retval;

	}
	// $ANTLR end "condExpr"

	partial void EnterRule_aexpr();
	partial void LeaveRule_aexpr();

	// $ANTLR start "aexpr"
	// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:71:1: aexpr : mexpr ( '+' ^ mexpr )* ;
	[GrammarRule("aexpr")]
	private AstParserRuleReturnScope<object, IToken> aexpr()
	{
		EnterRule_aexpr();
		EnterRule("aexpr", 13);
		TraceIn("aexpr", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal44 = default(IToken);
		AstParserRuleReturnScope<object, IToken> mexpr43 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mexpr45 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal44_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "aexpr");
		DebugLocation(71, 4);
		try
		{
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:72:5: ( mexpr ( '+' ^ mexpr )* )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:72:9: mexpr ( '+' ^ mexpr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(72, 9);
			PushFollow(Follow._mexpr_in_aexpr528);
			mexpr43=mexpr();
			PopFollow();

			adaptor.AddChild(root_0, mexpr43.Tree);
			DebugLocation(72, 15);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:72:15: ( '+' ^ mexpr )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==15))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:72:16: '+' ^ mexpr
					{
					DebugLocation(72, 19);
					char_literal44=(IToken)Match(input,15,Follow._15_in_aexpr531); 
					char_literal44_tree = (object)adaptor.Create(char_literal44);
					root_0 = (object)adaptor.BecomeRoot(char_literal44_tree, root_0);
					DebugLocation(72, 21);
					PushFollow(Follow._mexpr_in_aexpr534);
					mexpr45=mexpr();
					PopFollow();

					adaptor.AddChild(root_0, mexpr45.Tree);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("aexpr", 13);
			LeaveRule("aexpr", 13);
			LeaveRule_aexpr();
		}
		DebugLocation(73, 4);
		} finally { DebugExitRule(GrammarFileName, "aexpr"); }
		return retval;

	}
	// $ANTLR end "aexpr"

	partial void EnterRule_mexpr();
	partial void LeaveRule_mexpr();

	// $ANTLR start "mexpr"
	// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:75:1: mexpr : atom ( '*' ^ atom )* ;
	[GrammarRule("mexpr")]
	private AstParserRuleReturnScope<object, IToken> mexpr()
	{
		EnterRule_mexpr();
		EnterRule("mexpr", 14);
		TraceIn("mexpr", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal47 = default(IToken);
		AstParserRuleReturnScope<object, IToken> atom46 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> atom48 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal47_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "mexpr");
		DebugLocation(75, 4);
		try
		{
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:76:5: ( atom ( '*' ^ atom )* )
			DebugEnterAlt(1);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:76:9: atom ( '*' ^ atom )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(76, 9);
			PushFollow(Follow._atom_in_mexpr555);
			atom46=atom();
			PopFollow();

			adaptor.AddChild(root_0, atom46.Tree);
			DebugLocation(76, 14);
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:76:14: ( '*' ^ atom )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if ((LA11_0==14))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:76:15: '*' ^ atom
					{
					DebugLocation(76, 18);
					char_literal47=(IToken)Match(input,14,Follow._14_in_mexpr558); 
					char_literal47_tree = (object)adaptor.Create(char_literal47);
					root_0 = (object)adaptor.BecomeRoot(char_literal47_tree, root_0);
					DebugLocation(76, 20);
					PushFollow(Follow._atom_in_mexpr561);
					atom48=atom();
					PopFollow();

					adaptor.AddChild(root_0, atom48.Tree);

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("mexpr", 14);
			LeaveRule("mexpr", 14);
			LeaveRule_mexpr();
		}
		DebugLocation(77, 4);
		} finally { DebugExitRule(GrammarFileName, "mexpr"); }
		return retval;

	}
	// $ANTLR end "mexpr"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:79:1: atom : ( ID | INT | '(' expr ')' -> expr );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<object, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 15);
		TraceIn("atom", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID49 = default(IToken);
		IToken INT50 = default(IToken);
		IToken char_literal51 = default(IToken);
		IToken char_literal53 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr52 = default(AstParserRuleReturnScope<object, IToken>);

		object ID49_tree = default(object);
		object INT50_tree = default(object);
		object char_literal51_tree = default(object);
		object char_literal53_tree = default(object);
		RewriteRuleITokenStream stream_13=new RewriteRuleITokenStream(adaptor,"token 13");
		RewriteRuleITokenStream stream_12=new RewriteRuleITokenStream(adaptor,"token 12");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(79, 4);
		try
		{
			// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:79:5: ( ID | INT | '(' expr ')' -> expr )
			int alt12=3;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt12 = 1;
				}
				break;
			case INT:
				{
				alt12 = 2;
				}
				break;
			case 12:
				{
				alt12 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:79:9: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(79, 9);
				ID49=(IToken)Match(input,ID,Follow._ID_in_atom577); 
				ID49_tree = (object)adaptor.Create(ID49);
				adaptor.AddChild(root_0, ID49_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:80:9: INT
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(80, 9);
				INT50=(IToken)Match(input,INT,Follow._INT_in_atom587); 
				INT50_tree = (object)adaptor.Create(INT50);
				adaptor.AddChild(root_0, INT50_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Dev\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:81:9: '(' expr ')'
				{
				DebugLocation(81, 9);
				char_literal51=(IToken)Match(input,12,Follow._12_in_atom597);  
				stream_12.Add(char_literal51);

				DebugLocation(81, 13);
				PushFollow(Follow._expr_in_atom599);
				expr52=expr();
				PopFollow();

				stream_expr.Add(expr52.Tree);
				DebugLocation(81, 18);
				char_literal53=(IToken)Match(input,13,Follow._13_in_atom601);  
				stream_13.Add(char_literal53);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 81:22: -> expr
				{
					DebugLocation(81, 25);
					adaptor.AddChild(root_0, stream_expr.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 15);
			LeaveRule("atom", 15);
			LeaveRule_atom();
		}
		DebugLocation(82, 4);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _declaration_in_program67 = new BitSet(new ulong[]{0x500002UL});
		public static readonly BitSet _variable_in_declaration87 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_in_declaration97 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_in_variable116 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _ID_in_variable118 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_variable120 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_in_function174 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _ID_in_function176 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _12_in_function186 = new BitSet(new ulong[]{0x502000UL});
		public static readonly BitSet _formalParameter_in_function190 = new BitSet(new ulong[]{0x12000UL});
		public static readonly BitSet _16_in_function193 = new BitSet(new ulong[]{0x500000UL});
		public static readonly BitSet _formalParameter_in_function195 = new BitSet(new ulong[]{0x12000UL});
		public static readonly BitSet _13_in_function203 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _block_in_function213 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_in_formalParameter255 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _ID_in_formalParameter257 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _23_in_block289 = new BitSet(new ulong[]{0x1F210C0UL});
		public static readonly BitSet _variable_in_block291 = new BitSet(new ulong[]{0x1F210C0UL});
		public static readonly BitSet _stat_in_block294 = new BitSet(new ulong[]{0x1A210C0UL});
		public static readonly BitSet _24_in_block297 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forStat_in_stat330 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_stat338 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_stat340 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_stat349 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignStat_in_stat357 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_stat359 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _17_in_stat368 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _21_in_forStat388 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _12_in_forStat390 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _assignStat_in_forStat394 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_forStat396 = new BitSet(new ulong[]{0x10C0UL});
		public static readonly BitSet _expr_in_forStat398 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_forStat400 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _assignStat_in_forStat404 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _13_in_forStat406 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _block_in_forStat408 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assignStat451 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _18_in_assignStat453 = new BitSet(new ulong[]{0x10C0UL});
		public static readonly BitSet _expr_in_assignStat455 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _condExpr_in_expr479 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _aexpr_in_condExpr494 = new BitSet(new ulong[]{0x80802UL});
		public static readonly BitSet _19_in_condExpr499 = new BitSet(new ulong[]{0x10C0UL});
		public static readonly BitSet _11_in_condExpr502 = new BitSet(new ulong[]{0x10C0UL});
		public static readonly BitSet _aexpr_in_condExpr506 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _mexpr_in_aexpr528 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _15_in_aexpr531 = new BitSet(new ulong[]{0x10C0UL});
		public static readonly BitSet _mexpr_in_aexpr534 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _atom_in_mexpr555 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _14_in_mexpr558 = new BitSet(new ulong[]{0x10C0UL});
		public static readonly BitSet _atom_in_mexpr561 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _ID_in_atom577 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_atom587 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _12_in_atom597 = new BitSet(new ulong[]{0x10C0UL});
		public static readonly BitSet _expr_in_atom599 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _13_in_atom601 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
