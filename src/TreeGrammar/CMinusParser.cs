//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g 2012-03-07 17:14:25

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class CMinusParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ARG", "FUNC", "ID", "INT", "SLIST", "VAR", "WS", "'!='", "'('", "')'", "'*'", "'+'", "','", "';'", "'='", "'=='", "'char'", "'for'", "'int'", "'{'", "'}'"
	};
	public const int EOF=-1;
	public const int T__11=11;
	public const int T__12=12;
	public const int T__13=13;
	public const int T__14=14;
	public const int T__15=15;
	public const int T__16=16;
	public const int T__17=17;
	public const int T__18=18;
	public const int T__19=19;
	public const int T__20=20;
	public const int T__21=21;
	public const int T__22=22;
	public const int T__23=23;
	public const int T__24=24;
	public const int ARG=4;
	public const int FUNC=5;
	public const int ID=6;
	public const int INT=7;
	public const int SLIST=8;
	public const int VAR=9;
	public const int WS=10;

	public CMinusParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public CMinusParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return CMinusParser.tokenNames; } }
	public override string GrammarFileName { get { return "E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:14:1: program : ( declaration )+ ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> declaration1 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(14, 4);
		try
		{
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:15:5: ( ( declaration )+ )
			DebugEnterAlt(1);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:15:9: ( declaration )+
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(15, 9);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:15:9: ( declaration )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==20||LA1_0==22))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:15:9: declaration
					{
					DebugLocation(15, 9);
					PushFollow(Follow._declaration_in_program64);
					declaration1=declaration();
					PopFollow();

					adaptor.AddChild(root_0, declaration1.Tree);

					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(16, 4);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_declaration();
	partial void LeaveRule_declaration();

	// $ANTLR start "declaration"
	// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:18:1: declaration : ( variable | function );
	[GrammarRule("declaration")]
	private AstParserRuleReturnScope<object, IToken> declaration()
	{
		EnterRule_declaration();
		EnterRule("declaration", 2);
		TraceIn("declaration", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> variable2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> function3 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "declaration");
		DebugLocation(18, 4);
		try
		{
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:19:5: ( variable | function )
			int alt2=2;
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==20||LA2_0==22))
			{
				int LA2_1 = input.LA(2);

				if ((LA2_1==ID))
				{
					int LA2_2 = input.LA(3);

					if ((LA2_2==17))
					{
						alt2 = 1;
					}
					else if ((LA2_2==12))
					{
						alt2 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 2, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:19:9: variable
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(19, 9);
				PushFollow(Follow._variable_in_declaration84);
				variable2=variable();
				PopFollow();

				adaptor.AddChild(root_0, variable2.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:20:9: function
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(20, 9);
				PushFollow(Follow._function_in_declaration94);
				function3=function();
				PopFollow();

				adaptor.AddChild(root_0, function3.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration", 2);
			LeaveRule("declaration", 2);
			LeaveRule_declaration();
		}
		DebugLocation(21, 4);
		} finally { DebugExitRule(GrammarFileName, "declaration"); }
		return retval;

	}
	// $ANTLR end "declaration"

	partial void EnterRule_variable();
	partial void LeaveRule_variable();

	// $ANTLR start "variable"
	// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:23:1: variable : type ID ';' -> ^( VAR type ID ) ;
	[GrammarRule("variable")]
	private AstParserRuleReturnScope<object, IToken> variable()
	{
		EnterRule_variable();
		EnterRule("variable", 3);
		TraceIn("variable", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID5 = default(IToken);
		IToken char_literal6 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type4 = default(AstParserRuleReturnScope<object, IToken>);

		object ID5_tree = default(object);
		object char_literal6_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_17=new RewriteRuleITokenStream(adaptor,"token 17");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "variable");
		DebugLocation(23, 4);
		try
		{
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:24:5: ( type ID ';' -> ^( VAR type ID ) )
			DebugEnterAlt(1);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:24:9: type ID ';'
			{
			DebugLocation(24, 9);
			PushFollow(Follow._type_in_variable113);
			type4=type();
			PopFollow();

			stream_type.Add(type4.Tree);
			DebugLocation(24, 14);
			ID5=(IToken)Match(input,ID,Follow._ID_in_variable115);  
			stream_ID.Add(ID5);

			DebugLocation(24, 17);
			char_literal6=(IToken)Match(input,17,Follow._17_in_variable117);  
			stream_17.Add(char_literal6);



			{
			// AST REWRITE
			// elements: type, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 24:21: -> ^( VAR type ID )
			{
				DebugLocation(24, 24);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:24:24: ^( VAR type ID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(24, 26);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR, "VAR"), root_1);

				DebugLocation(24, 30);
				adaptor.AddChild(root_1, stream_type.NextTree());
				DebugLocation(24, 35);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variable", 3);
			LeaveRule("variable", 3);
			LeaveRule_variable();
		}
		DebugLocation(25, 4);
		} finally { DebugExitRule(GrammarFileName, "variable"); }
		return retval;

	}
	// $ANTLR end "variable"

	partial void EnterRule_type();
	partial void LeaveRule_type();

	// $ANTLR start "type"
	// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:27:1: type : ( 'int' | 'char' );
	[GrammarRule("type")]
	private AstParserRuleReturnScope<object, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 4);
		TraceIn("type", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set7 = default(IToken);

		object set7_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(27, 4);
		try
		{
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:27:5: ( 'int' | 'char' )
			DebugEnterAlt(1);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(27, 5);

			set7=(IToken)input.LT(1);
			if (input.LA(1)==20||input.LA(1)==22)
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set7));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 4);
			LeaveRule("type", 4);
			LeaveRule_type();
		}
		DebugLocation(29, 4);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	partial void EnterRule_function();
	partial void LeaveRule_function();

	// $ANTLR start "function"
	// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:31:1: function : type ID '(' ( formalParameter ( ',' formalParameter )* )? ')' block -> ^( FUNC type ID ( formalParameter )* block ) ;
	[GrammarRule("function")]
	private AstParserRuleReturnScope<object, IToken> function()
	{
		EnterRule_function();
		EnterRule("function", 5);
		TraceIn("function", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID9 = default(IToken);
		IToken char_literal10 = default(IToken);
		IToken char_literal12 = default(IToken);
		IToken char_literal14 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type8 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> formalParameter11 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> formalParameter13 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> block15 = default(AstParserRuleReturnScope<object, IToken>);

		object ID9_tree = default(object);
		object char_literal10_tree = default(object);
		object char_literal12_tree = default(object);
		object char_literal14_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_16=new RewriteRuleITokenStream(adaptor,"token 16");
		RewriteRuleITokenStream stream_13=new RewriteRuleITokenStream(adaptor,"token 13");
		RewriteRuleITokenStream stream_12=new RewriteRuleITokenStream(adaptor,"token 12");
		RewriteRuleSubtreeStream stream_formalParameter=new RewriteRuleSubtreeStream(adaptor,"rule formalParameter");
		RewriteRuleSubtreeStream stream_block=new RewriteRuleSubtreeStream(adaptor,"rule block");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "function");
		DebugLocation(31, 4);
		try
		{
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:32:5: ( type ID '(' ( formalParameter ( ',' formalParameter )* )? ')' block -> ^( FUNC type ID ( formalParameter )* block ) )
			DebugEnterAlt(1);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:32:9: type ID '(' ( formalParameter ( ',' formalParameter )* )? ')' block
			{
			DebugLocation(32, 9);
			PushFollow(Follow._type_in_function171);
			type8=type();
			PopFollow();

			stream_type.Add(type8.Tree);
			DebugLocation(32, 14);
			ID9=(IToken)Match(input,ID,Follow._ID_in_function173);  
			stream_ID.Add(ID9);

			DebugLocation(33, 9);
			char_literal10=(IToken)Match(input,12,Follow._12_in_function183);  
			stream_12.Add(char_literal10);

			DebugLocation(33, 13);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:33:13: ( formalParameter ( ',' formalParameter )* )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==20||LA4_0==22))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:33:15: formalParameter ( ',' formalParameter )*
				{
				DebugLocation(33, 15);
				PushFollow(Follow._formalParameter_in_function187);
				formalParameter11=formalParameter();
				PopFollow();

				stream_formalParameter.Add(formalParameter11.Tree);
				DebugLocation(33, 31);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:33:31: ( ',' formalParameter )*
				try { DebugEnterSubRule(3);
				while (true)
				{
					int alt3=2;
					try { DebugEnterDecision(3, false);
					int LA3_0 = input.LA(1);

					if ((LA3_0==16))
					{
						alt3 = 1;
					}


					} finally { DebugExitDecision(3); }
					switch ( alt3 )
					{
					case 1:
						DebugEnterAlt(1);
						// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:33:32: ',' formalParameter
						{
						DebugLocation(33, 32);
						char_literal12=(IToken)Match(input,16,Follow._16_in_function190);  
						stream_16.Add(char_literal12);

						DebugLocation(33, 36);
						PushFollow(Follow._formalParameter_in_function192);
						formalParameter13=formalParameter();
						PopFollow();

						stream_formalParameter.Add(formalParameter13.Tree);

						}
						break;

					default:
						goto loop3;
					}
				}

				loop3:
					;

				} finally { DebugExitSubRule(3); }


				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(33, 58);
			char_literal14=(IToken)Match(input,13,Follow._13_in_function200);  
			stream_13.Add(char_literal14);

			DebugLocation(34, 9);
			PushFollow(Follow._block_in_function210);
			block15=block();
			PopFollow();

			stream_block.Add(block15.Tree);


			{
			// AST REWRITE
			// elements: block, type, formalParameter, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 35:9: -> ^( FUNC type ID ( formalParameter )* block )
			{
				DebugLocation(35, 12);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:35:12: ^( FUNC type ID ( formalParameter )* block )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(35, 14);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNC, "FUNC"), root_1);

				DebugLocation(35, 19);
				adaptor.AddChild(root_1, stream_type.NextTree());
				DebugLocation(35, 24);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(35, 27);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:35:27: ( formalParameter )*
				while ( stream_formalParameter.HasNext )
				{
					DebugLocation(35, 27);
					adaptor.AddChild(root_1, stream_formalParameter.NextTree());

				}
				stream_formalParameter.Reset();
				DebugLocation(35, 44);
				adaptor.AddChild(root_1, stream_block.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("function", 5);
			LeaveRule("function", 5);
			LeaveRule_function();
		}
		DebugLocation(36, 4);
		} finally { DebugExitRule(GrammarFileName, "function"); }
		return retval;

	}
	// $ANTLR end "function"

	partial void EnterRule_formalParameter();
	partial void LeaveRule_formalParameter();

	// $ANTLR start "formalParameter"
	// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:38:1: formalParameter : type ID -> ^( ARG type ID ) ;
	[GrammarRule("formalParameter")]
	private AstParserRuleReturnScope<object, IToken> formalParameter()
	{
		EnterRule_formalParameter();
		EnterRule("formalParameter", 6);
		TraceIn("formalParameter", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID17 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type16 = default(AstParserRuleReturnScope<object, IToken>);

		object ID17_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "formalParameter");
		DebugLocation(38, 4);
		try
		{
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:39:5: ( type ID -> ^( ARG type ID ) )
			DebugEnterAlt(1);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:39:9: type ID
			{
			DebugLocation(39, 9);
			PushFollow(Follow._type_in_formalParameter252);
			type16=type();
			PopFollow();

			stream_type.Add(type16.Tree);
			DebugLocation(39, 14);
			ID17=(IToken)Match(input,ID,Follow._ID_in_formalParameter254);  
			stream_ID.Add(ID17);



			{
			// AST REWRITE
			// elements: type, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 39:17: -> ^( ARG type ID )
			{
				DebugLocation(39, 20);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:39:20: ^( ARG type ID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(39, 22);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARG, "ARG"), root_1);

				DebugLocation(39, 26);
				adaptor.AddChild(root_1, stream_type.NextTree());
				DebugLocation(39, 31);
				adaptor.AddChild(root_1, stream_ID.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("formalParameter", 6);
			LeaveRule("formalParameter", 6);
			LeaveRule_formalParameter();
		}
		DebugLocation(40, 4);
		} finally { DebugExitRule(GrammarFileName, "formalParameter"); }
		return retval;

	}
	// $ANTLR end "formalParameter"

	partial void EnterRule_block();
	partial void LeaveRule_block();

	// $ANTLR start "block"
	// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:43:1: block : lc= '{' ( variable )* ( stat )* '}' -> ^( SLIST[$lc,\"SLIST\"] ( variable )* ( stat )* ) ;
	[GrammarRule("block")]
	private AstParserRuleReturnScope<object, IToken> block()
	{
		EnterRule_block();
		EnterRule("block", 7);
		TraceIn("block", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken lc = default(IToken);
		IToken char_literal20 = default(IToken);
		AstParserRuleReturnScope<object, IToken> variable18 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> stat19 = default(AstParserRuleReturnScope<object, IToken>);

		object lc_tree = default(object);
		object char_literal20_tree = default(object);
		RewriteRuleITokenStream stream_23=new RewriteRuleITokenStream(adaptor,"token 23");
		RewriteRuleITokenStream stream_24=new RewriteRuleITokenStream(adaptor,"token 24");
		RewriteRuleSubtreeStream stream_variable=new RewriteRuleSubtreeStream(adaptor,"rule variable");
		RewriteRuleSubtreeStream stream_stat=new RewriteRuleSubtreeStream(adaptor,"rule stat");
		try { DebugEnterRule(GrammarFileName, "block");
		DebugLocation(43, 4);
		try
		{
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:44:5: (lc= '{' ( variable )* ( stat )* '}' -> ^( SLIST[$lc,\"SLIST\"] ( variable )* ( stat )* ) )
			DebugEnterAlt(1);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:44:9: lc= '{' ( variable )* ( stat )* '}'
			{
			DebugLocation(44, 11);
			lc=(IToken)Match(input,23,Follow._23_in_block286);  
			stream_23.Add(lc);

			DebugLocation(44, 16);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:44:16: ( variable )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==20||LA5_0==22))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:44:16: variable
					{
					DebugLocation(44, 16);
					PushFollow(Follow._variable_in_block288);
					variable18=variable();
					PopFollow();

					stream_variable.Add(variable18.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(44, 26);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:44:26: ( stat )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if (((LA6_0>=ID && LA6_0<=INT)||LA6_0==12||LA6_0==17||LA6_0==21||LA6_0==23))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:44:26: stat
					{
					DebugLocation(44, 26);
					PushFollow(Follow._stat_in_block291);
					stat19=stat();
					PopFollow();

					stream_stat.Add(stat19.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(44, 32);
			char_literal20=(IToken)Match(input,24,Follow._24_in_block294);  
			stream_24.Add(char_literal20);



			{
			// AST REWRITE
			// elements: stat, variable
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 45:9: -> ^( SLIST[$lc,\"SLIST\"] ( variable )* ( stat )* )
			{
				DebugLocation(45, 12);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:45:12: ^( SLIST[$lc,\"SLIST\"] ( variable )* ( stat )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(45, 14);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SLIST, lc, "SLIST"), root_1);

				DebugLocation(45, 33);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:45:33: ( variable )*
				while ( stream_variable.HasNext )
				{
					DebugLocation(45, 33);
					adaptor.AddChild(root_1, stream_variable.NextTree());

				}
				stream_variable.Reset();
				DebugLocation(45, 43);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:45:43: ( stat )*
				while ( stream_stat.HasNext )
				{
					DebugLocation(45, 43);
					adaptor.AddChild(root_1, stream_stat.NextTree());

				}
				stream_stat.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("block", 7);
			LeaveRule("block", 7);
			LeaveRule_block();
		}
		DebugLocation(46, 4);
		} finally { DebugExitRule(GrammarFileName, "block"); }
		return retval;

	}
	// $ANTLR end "block"

	partial void EnterRule_stat();
	partial void LeaveRule_stat();

	// $ANTLR start "stat"
	// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:48:1: stat : ( forStat | expr ';' !| block | assignStat ';' !| ';' !);
	[GrammarRule("stat")]
	private AstParserRuleReturnScope<object, IToken> stat()
	{
		EnterRule_stat();
		EnterRule("stat", 8);
		TraceIn("stat", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal23 = default(IToken);
		IToken char_literal26 = default(IToken);
		IToken char_literal27 = default(IToken);
		AstParserRuleReturnScope<object, IToken> forStat21 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> block24 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignStat25 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal23_tree = default(object);
		object char_literal26_tree = default(object);
		object char_literal27_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "stat");
		DebugLocation(48, 4);
		try
		{
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:48:5: ( forStat | expr ';' !| block | assignStat ';' !| ';' !)
			int alt7=5;
			try { DebugEnterDecision(7, false);
			switch (input.LA(1))
			{
			case 21:
				{
				alt7 = 1;
				}
				break;
			case ID:
				{
				int LA7_2 = input.LA(2);

				if ((LA7_2==18))
				{
					alt7 = 4;
				}
				else if ((LA7_2==11||(LA7_2>=14 && LA7_2<=15)||LA7_2==17||LA7_2==19))
				{
					alt7 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 7, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case INT:
			case 12:
				{
				alt7 = 2;
				}
				break;
			case 23:
				{
				alt7 = 3;
				}
				break;
			case 17:
				{
				alt7 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:48:7: forStat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(48, 7);
				PushFollow(Follow._forStat_in_stat327);
				forStat21=forStat();
				PopFollow();

				adaptor.AddChild(root_0, forStat21.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:49:7: expr ';' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(49, 7);
				PushFollow(Follow._expr_in_stat335);
				expr22=expr();
				PopFollow();

				adaptor.AddChild(root_0, expr22.Tree);
				DebugLocation(49, 15);
				char_literal23=(IToken)Match(input,17,Follow._17_in_stat337); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:50:7: block
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(50, 7);
				PushFollow(Follow._block_in_stat346);
				block24=block();
				PopFollow();

				adaptor.AddChild(root_0, block24.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:51:7: assignStat ';' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(51, 7);
				PushFollow(Follow._assignStat_in_stat354);
				assignStat25=assignStat();
				PopFollow();

				adaptor.AddChild(root_0, assignStat25.Tree);
				DebugLocation(51, 21);
				char_literal26=(IToken)Match(input,17,Follow._17_in_stat356); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:52:7: ';' !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(52, 10);
				char_literal27=(IToken)Match(input,17,Follow._17_in_stat365); 

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stat", 8);
			LeaveRule("stat", 8);
			LeaveRule_stat();
		}
		DebugLocation(53, 4);
		} finally { DebugExitRule(GrammarFileName, "stat"); }
		return retval;

	}
	// $ANTLR end "stat"

	partial void EnterRule_forStat();
	partial void LeaveRule_forStat();

	// $ANTLR start "forStat"
	// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:55:1: forStat : 'for' '(' first= assignStat ';' expr ';' inc= assignStat ')' block -> ^( 'for' $first expr $inc block ) ;
	[GrammarRule("forStat")]
	private AstParserRuleReturnScope<object, IToken> forStat()
	{
		EnterRule_forStat();
		EnterRule("forStat", 9);
		TraceIn("forStat", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal28 = default(IToken);
		IToken char_literal29 = default(IToken);
		IToken char_literal30 = default(IToken);
		IToken char_literal32 = default(IToken);
		IToken char_literal33 = default(IToken);
		AstParserRuleReturnScope<object, IToken> first = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> inc = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr31 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> block34 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal28_tree = default(object);
		object char_literal29_tree = default(object);
		object char_literal30_tree = default(object);
		object char_literal32_tree = default(object);
		object char_literal33_tree = default(object);
		RewriteRuleITokenStream stream_21=new RewriteRuleITokenStream(adaptor,"token 21");
		RewriteRuleITokenStream stream_17=new RewriteRuleITokenStream(adaptor,"token 17");
		RewriteRuleITokenStream stream_13=new RewriteRuleITokenStream(adaptor,"token 13");
		RewriteRuleITokenStream stream_12=new RewriteRuleITokenStream(adaptor,"token 12");
		RewriteRuleSubtreeStream stream_assignStat=new RewriteRuleSubtreeStream(adaptor,"rule assignStat");
		RewriteRuleSubtreeStream stream_block=new RewriteRuleSubtreeStream(adaptor,"rule block");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "forStat");
		DebugLocation(55, 4);
		try
		{
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:56:5: ( 'for' '(' first= assignStat ';' expr ';' inc= assignStat ')' block -> ^( 'for' $first expr $inc block ) )
			DebugEnterAlt(1);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:56:9: 'for' '(' first= assignStat ';' expr ';' inc= assignStat ')' block
			{
			DebugLocation(56, 9);
			string_literal28=(IToken)Match(input,21,Follow._21_in_forStat385);  
			stream_21.Add(string_literal28);

			DebugLocation(56, 15);
			char_literal29=(IToken)Match(input,12,Follow._12_in_forStat387);  
			stream_12.Add(char_literal29);

			DebugLocation(56, 24);
			PushFollow(Follow._assignStat_in_forStat391);
			first=assignStat();
			PopFollow();

			stream_assignStat.Add(first.Tree);
			DebugLocation(56, 36);
			char_literal30=(IToken)Match(input,17,Follow._17_in_forStat393);  
			stream_17.Add(char_literal30);

			DebugLocation(56, 40);
			PushFollow(Follow._expr_in_forStat395);
			expr31=expr();
			PopFollow();

			stream_expr.Add(expr31.Tree);
			DebugLocation(56, 45);
			char_literal32=(IToken)Match(input,17,Follow._17_in_forStat397);  
			stream_17.Add(char_literal32);

			DebugLocation(56, 52);
			PushFollow(Follow._assignStat_in_forStat401);
			inc=assignStat();
			PopFollow();

			stream_assignStat.Add(inc.Tree);
			DebugLocation(56, 64);
			char_literal33=(IToken)Match(input,13,Follow._13_in_forStat403);  
			stream_13.Add(char_literal33);

			DebugLocation(56, 68);
			PushFollow(Follow._block_in_forStat405);
			block34=block();
			PopFollow();

			stream_block.Add(block34.Tree);


			{
			// AST REWRITE
			// elements: inc, block, expr, first, 21
			// token labels: 
			// rule labels: retval, inc, first
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_inc=new RewriteRuleSubtreeStream(adaptor,"rule inc",inc!=null?inc.Tree:null);
			RewriteRuleSubtreeStream stream_first=new RewriteRuleSubtreeStream(adaptor,"rule first",first!=null?first.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 57:9: -> ^( 'for' $first expr $inc block )
			{
				DebugLocation(57, 12);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:57:12: ^( 'for' $first expr $inc block )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(57, 14);
				root_1 = (object)adaptor.BecomeRoot(stream_21.NextNode(), root_1);

				DebugLocation(57, 21);
				adaptor.AddChild(root_1, stream_first.NextTree());
				DebugLocation(57, 27);
				adaptor.AddChild(root_1, stream_expr.NextTree());
				DebugLocation(57, 33);
				adaptor.AddChild(root_1, stream_inc.NextTree());
				DebugLocation(57, 37);
				adaptor.AddChild(root_1, stream_block.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forStat", 9);
			LeaveRule("forStat", 9);
			LeaveRule_forStat();
		}
		DebugLocation(58, 4);
		} finally { DebugExitRule(GrammarFileName, "forStat"); }
		return retval;

	}
	// $ANTLR end "forStat"

	partial void EnterRule_assignStat();
	partial void LeaveRule_assignStat();

	// $ANTLR start "assignStat"
	// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:60:1: assignStat : ID '=' expr -> ^( '=' ID expr ) ;
	[GrammarRule("assignStat")]
	private AstParserRuleReturnScope<object, IToken> assignStat()
	{
		EnterRule_assignStat();
		EnterRule("assignStat", 10);
		TraceIn("assignStat", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID35 = default(IToken);
		IToken char_literal36 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr37 = default(AstParserRuleReturnScope<object, IToken>);

		object ID35_tree = default(object);
		object char_literal36_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_18=new RewriteRuleITokenStream(adaptor,"token 18");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "assignStat");
		DebugLocation(60, 4);
		try
		{
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:61:5: ( ID '=' expr -> ^( '=' ID expr ) )
			DebugEnterAlt(1);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:61:9: ID '=' expr
			{
			DebugLocation(61, 9);
			ID35=(IToken)Match(input,ID,Follow._ID_in_assignStat448);  
			stream_ID.Add(ID35);

			DebugLocation(61, 12);
			char_literal36=(IToken)Match(input,18,Follow._18_in_assignStat450);  
			stream_18.Add(char_literal36);

			DebugLocation(61, 16);
			PushFollow(Follow._expr_in_assignStat452);
			expr37=expr();
			PopFollow();

			stream_expr.Add(expr37.Tree);


			{
			// AST REWRITE
			// elements: ID, expr, 18
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 61:21: -> ^( '=' ID expr )
			{
				DebugLocation(61, 24);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:61:24: ^( '=' ID expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(61, 26);
				root_1 = (object)adaptor.BecomeRoot(stream_18.NextNode(), root_1);

				DebugLocation(61, 30);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(61, 33);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignStat", 10);
			LeaveRule("assignStat", 10);
			LeaveRule_assignStat();
		}
		DebugLocation(62, 4);
		} finally { DebugExitRule(GrammarFileName, "assignStat"); }
		return retval;

	}
	// $ANTLR end "assignStat"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:64:1: expr : condExpr ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<object, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 11);
		TraceIn("expr", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> condExpr38 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(64, 17);
		try
		{
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:64:5: ( condExpr )
			DebugEnterAlt(1);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:64:9: condExpr
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(64, 9);
			PushFollow(Follow._condExpr_in_expr476);
			condExpr38=condExpr();
			PopFollow();

			adaptor.AddChild(root_0, condExpr38.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 11);
			LeaveRule("expr", 11);
			LeaveRule_expr();
		}
		DebugLocation(64, 17);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_condExpr();
	partial void LeaveRule_condExpr();

	// $ANTLR start "condExpr"
	// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:66:1: condExpr : aexpr ( ( '==' ^| '!=' ^) aexpr )? ;
	[GrammarRule("condExpr")]
	private AstParserRuleReturnScope<object, IToken> condExpr()
	{
		EnterRule_condExpr();
		EnterRule("condExpr", 12);
		TraceIn("condExpr", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken string_literal40 = default(IToken);
		IToken string_literal41 = default(IToken);
		AstParserRuleReturnScope<object, IToken> aexpr39 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> aexpr42 = default(AstParserRuleReturnScope<object, IToken>);

		object string_literal40_tree = default(object);
		object string_literal41_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "condExpr");
		DebugLocation(66, 4);
		try
		{
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:67:5: ( aexpr ( ( '==' ^| '!=' ^) aexpr )? )
			DebugEnterAlt(1);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:67:9: aexpr ( ( '==' ^| '!=' ^) aexpr )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(67, 9);
			PushFollow(Follow._aexpr_in_condExpr491);
			aexpr39=aexpr();
			PopFollow();

			adaptor.AddChild(root_0, aexpr39.Tree);
			DebugLocation(67, 15);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:67:15: ( ( '==' ^| '!=' ^) aexpr )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_0 = input.LA(1);

			if ((LA9_0==11||LA9_0==19))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:67:17: ( '==' ^| '!=' ^) aexpr
				{
				DebugLocation(67, 17);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:67:17: ( '==' ^| '!=' ^)
				int alt8=2;
				try { DebugEnterSubRule(8);
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==19))
				{
					alt8 = 1;
				}
				else if ((LA8_0==11))
				{
					alt8 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(8); }
				switch (alt8)
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:67:18: '==' ^
					{
					DebugLocation(67, 22);
					string_literal40=(IToken)Match(input,19,Follow._19_in_condExpr496); 
					string_literal40_tree = (object)adaptor.Create(string_literal40);
					root_0 = (object)adaptor.BecomeRoot(string_literal40_tree, root_0);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:67:24: '!=' ^
					{
					DebugLocation(67, 28);
					string_literal41=(IToken)Match(input,11,Follow._11_in_condExpr499); 
					string_literal41_tree = (object)adaptor.Create(string_literal41);
					root_0 = (object)adaptor.BecomeRoot(string_literal41_tree, root_0);

					}
					break;

				}
				} finally { DebugExitSubRule(8); }

				DebugLocation(67, 31);
				PushFollow(Follow._aexpr_in_condExpr503);
				aexpr42=aexpr();
				PopFollow();

				adaptor.AddChild(root_0, aexpr42.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(9); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("condExpr", 12);
			LeaveRule("condExpr", 12);
			LeaveRule_condExpr();
		}
		DebugLocation(68, 4);
		} finally { DebugExitRule(GrammarFileName, "condExpr"); }
		return retval;

	}
	// $ANTLR end "condExpr"

	partial void EnterRule_aexpr();
	partial void LeaveRule_aexpr();

	// $ANTLR start "aexpr"
	// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:70:1: aexpr : mexpr ( '+' ^ mexpr )* ;
	[GrammarRule("aexpr")]
	private AstParserRuleReturnScope<object, IToken> aexpr()
	{
		EnterRule_aexpr();
		EnterRule("aexpr", 13);
		TraceIn("aexpr", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal44 = default(IToken);
		AstParserRuleReturnScope<object, IToken> mexpr43 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> mexpr45 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal44_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "aexpr");
		DebugLocation(70, 4);
		try
		{
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:71:5: ( mexpr ( '+' ^ mexpr )* )
			DebugEnterAlt(1);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:71:9: mexpr ( '+' ^ mexpr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(71, 9);
			PushFollow(Follow._mexpr_in_aexpr525);
			mexpr43=mexpr();
			PopFollow();

			adaptor.AddChild(root_0, mexpr43.Tree);
			DebugLocation(71, 15);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:71:15: ( '+' ^ mexpr )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==15))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:71:16: '+' ^ mexpr
					{
					DebugLocation(71, 19);
					char_literal44=(IToken)Match(input,15,Follow._15_in_aexpr528); 
					char_literal44_tree = (object)adaptor.Create(char_literal44);
					root_0 = (object)adaptor.BecomeRoot(char_literal44_tree, root_0);
					DebugLocation(71, 21);
					PushFollow(Follow._mexpr_in_aexpr531);
					mexpr45=mexpr();
					PopFollow();

					adaptor.AddChild(root_0, mexpr45.Tree);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("aexpr", 13);
			LeaveRule("aexpr", 13);
			LeaveRule_aexpr();
		}
		DebugLocation(72, 4);
		} finally { DebugExitRule(GrammarFileName, "aexpr"); }
		return retval;

	}
	// $ANTLR end "aexpr"

	partial void EnterRule_mexpr();
	partial void LeaveRule_mexpr();

	// $ANTLR start "mexpr"
	// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:74:1: mexpr : atom ( '*' ^ atom )* ;
	[GrammarRule("mexpr")]
	private AstParserRuleReturnScope<object, IToken> mexpr()
	{
		EnterRule_mexpr();
		EnterRule("mexpr", 14);
		TraceIn("mexpr", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken char_literal47 = default(IToken);
		AstParserRuleReturnScope<object, IToken> atom46 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> atom48 = default(AstParserRuleReturnScope<object, IToken>);

		object char_literal47_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "mexpr");
		DebugLocation(74, 4);
		try
		{
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:75:5: ( atom ( '*' ^ atom )* )
			DebugEnterAlt(1);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:75:9: atom ( '*' ^ atom )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(75, 9);
			PushFollow(Follow._atom_in_mexpr552);
			atom46=atom();
			PopFollow();

			adaptor.AddChild(root_0, atom46.Tree);
			DebugLocation(75, 14);
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:75:14: ( '*' ^ atom )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if ((LA11_0==14))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:75:15: '*' ^ atom
					{
					DebugLocation(75, 18);
					char_literal47=(IToken)Match(input,14,Follow._14_in_mexpr555); 
					char_literal47_tree = (object)adaptor.Create(char_literal47);
					root_0 = (object)adaptor.BecomeRoot(char_literal47_tree, root_0);
					DebugLocation(75, 20);
					PushFollow(Follow._atom_in_mexpr558);
					atom48=atom();
					PopFollow();

					adaptor.AddChild(root_0, atom48.Tree);

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("mexpr", 14);
			LeaveRule("mexpr", 14);
			LeaveRule_mexpr();
		}
		DebugLocation(76, 4);
		} finally { DebugExitRule(GrammarFileName, "mexpr"); }
		return retval;

	}
	// $ANTLR end "mexpr"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:78:1: atom : ( ID | INT | '(' expr ')' -> expr );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<object, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 15);
		TraceIn("atom", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID49 = default(IToken);
		IToken INT50 = default(IToken);
		IToken char_literal51 = default(IToken);
		IToken char_literal53 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr52 = default(AstParserRuleReturnScope<object, IToken>);

		object ID49_tree = default(object);
		object INT50_tree = default(object);
		object char_literal51_tree = default(object);
		object char_literal53_tree = default(object);
		RewriteRuleITokenStream stream_13=new RewriteRuleITokenStream(adaptor,"token 13");
		RewriteRuleITokenStream stream_12=new RewriteRuleITokenStream(adaptor,"token 12");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(78, 4);
		try
		{
			// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:78:5: ( ID | INT | '(' expr ')' -> expr )
			int alt12=3;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt12 = 1;
				}
				break;
			case INT:
				{
				alt12 = 2;
				}
				break;
			case 12:
				{
				alt12 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:78:9: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(78, 9);
				ID49=(IToken)Match(input,ID,Follow._ID_in_atom574); 
				ID49_tree = (object)adaptor.Create(ID49);
				adaptor.AddChild(root_0, ID49_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:79:9: INT
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(79, 9);
				INT50=(IToken)Match(input,INT,Follow._INT_in_atom584); 
				INT50_tree = (object)adaptor.Create(INT50);
				adaptor.AddChild(root_0, INT50_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// E:\\Git\\ANTLR-Lab\\src\\TreeGrammar\\CMinus.g:80:9: '(' expr ')'
				{
				DebugLocation(80, 9);
				char_literal51=(IToken)Match(input,12,Follow._12_in_atom594);  
				stream_12.Add(char_literal51);

				DebugLocation(80, 13);
				PushFollow(Follow._expr_in_atom596);
				expr52=expr();
				PopFollow();

				stream_expr.Add(expr52.Tree);
				DebugLocation(80, 18);
				char_literal53=(IToken)Match(input,13,Follow._13_in_atom598);  
				stream_13.Add(char_literal53);



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 80:22: -> expr
				{
					DebugLocation(80, 25);
					adaptor.AddChild(root_0, stream_expr.NextTree());

				}

				retval.Tree = root_0;
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 15);
			LeaveRule("atom", 15);
			LeaveRule_atom();
		}
		DebugLocation(81, 4);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _declaration_in_program64 = new BitSet(new ulong[]{0x500002UL});
		public static readonly BitSet _variable_in_declaration84 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _function_in_declaration94 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_in_variable113 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _ID_in_variable115 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_variable117 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_in_function171 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _ID_in_function173 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _12_in_function183 = new BitSet(new ulong[]{0x502000UL});
		public static readonly BitSet _formalParameter_in_function187 = new BitSet(new ulong[]{0x12000UL});
		public static readonly BitSet _16_in_function190 = new BitSet(new ulong[]{0x500000UL});
		public static readonly BitSet _formalParameter_in_function192 = new BitSet(new ulong[]{0x12000UL});
		public static readonly BitSet _13_in_function200 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _block_in_function210 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_in_formalParameter252 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _ID_in_formalParameter254 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _23_in_block286 = new BitSet(new ulong[]{0x1F210C0UL});
		public static readonly BitSet _variable_in_block288 = new BitSet(new ulong[]{0x1F210C0UL});
		public static readonly BitSet _stat_in_block291 = new BitSet(new ulong[]{0x1A210C0UL});
		public static readonly BitSet _24_in_block294 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forStat_in_stat327 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_stat335 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_stat337 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_stat346 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignStat_in_stat354 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_stat356 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _17_in_stat365 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _21_in_forStat385 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _12_in_forStat387 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _assignStat_in_forStat391 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_forStat393 = new BitSet(new ulong[]{0x10C0UL});
		public static readonly BitSet _expr_in_forStat395 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_forStat397 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _assignStat_in_forStat401 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _13_in_forStat403 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _block_in_forStat405 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assignStat448 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _18_in_assignStat450 = new BitSet(new ulong[]{0x10C0UL});
		public static readonly BitSet _expr_in_assignStat452 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _condExpr_in_expr476 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _aexpr_in_condExpr491 = new BitSet(new ulong[]{0x80802UL});
		public static readonly BitSet _19_in_condExpr496 = new BitSet(new ulong[]{0x10C0UL});
		public static readonly BitSet _11_in_condExpr499 = new BitSet(new ulong[]{0x10C0UL});
		public static readonly BitSet _aexpr_in_condExpr503 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _mexpr_in_aexpr525 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _15_in_aexpr528 = new BitSet(new ulong[]{0x10C0UL});
		public static readonly BitSet _mexpr_in_aexpr531 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _atom_in_mexpr552 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _14_in_mexpr555 = new BitSet(new ulong[]{0x10C0UL});
		public static readonly BitSet _atom_in_mexpr558 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _ID_in_atom574 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_atom584 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _12_in_atom594 = new BitSet(new ulong[]{0x10C0UL});
		public static readonly BitSet _expr_in_atom596 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _13_in_atom598 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
